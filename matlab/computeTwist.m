function cmd_vel = computeTwist(...
    pose,...
	force,...
	robot_vel_glob,...
	sim_period,...
	robot_mass,...
	min_vel_x,...
	max_vel_x,...
	max_rot_vel...
)   
    force_v = force;
	dt = sim_period;

	% force to global velocity
	acc_v = force_v / robot_mass;
	vel_v = [robot_vel_glob(1), robot_vel_glob(2), robot_vel_glob(3)];
	dvel_v = acc_v * dt;
	vel_v_new = vel_v + dvel_v;

    fprintf("[     computeTwist    ] force = [%2.4f, %2.4f, %2.4f], vel_prev = [%2.4f, %2.4f, %2.4f]\n",...
        force_v(1), force_v(2), force_v(3),...
        vel_v(1), vel_v(2), vel_v(3)...
	);
    fprintf("[     computeTwist    ] dvel  = [%2.4f, %2.4f, %2.4f], vel_new  = [%2.4f, %2.4f, %2.4f]\n",...
        dvel_v(1), dvel_v(2), dvel_v(3),...
        vel_v_new(1), vel_v_new(2), vel_v_new(3)...
	);

    % orientation of the force vector in the odometry frame
    force_v_normalized = force_v / norm(force_v);
    angle_force_v = atan2(force_v_normalized(2), force_v_normalized(1));
    angle_force_v = wrapToPi(angle_force_v);
    
    % old version
    vel_v_new_normalized = vel_v_new / norm(vel_v_new);
    angle_vel_v_new = atan2(vel_v_new_normalized(2), vel_v_new_normalized(1));
    
    % angle_diff -> required rotation to go straight along the force
    angle_diff = angle_vel_v_new - pose(3);
    angle_diff = wrapToPi(angle_diff); % normalize

    fprintf("[     computeTwist    ] force dir: %2.4f째, base orient: %2.4f째, vel_v dir: %2.4f째, vel-base diff: %2.4f째\n",...
            rad2deg(angle_force_v),...
            rad2deg(pose(3)),...
            rad2deg(angle_vel_v_new),...
            rad2deg(angle_diff)...
    );

    amplitude = norm(force_v);
    lin_x = cos(angle_diff) * amplitude;
    ang_z = sin(angle_diff) * amplitude;
    cmd_vel = [lin_x, 0, ang_z];

    fprintf("[     computeTwist    ] linear = %2.4f (max = %2.4f), angular = %2.4f (max = %2.4f)\n",...
        cmd_vel(1),...
        max_vel_x,...
        cmd_vel(3),...
        max_rot_vel...
	);

    % check if within limits: try to maintain path, ignoring trajectory
    if max_vel_x < cmd_vel(1) || max_rot_vel < abs(cmd_vel(3))
       vel_x_excess = cmd_vel(1) / max_vel_x;
       vel_rot_excess = cmd_vel(3) / max_rot_vel;
       vel_shortening_factor = 1 / max(vel_x_excess, vel_rot_excess);
       cmd_vel(1) = cmd_vel(1) * vel_shortening_factor;
       cmd_vel(3) = cmd_vel(3) * vel_shortening_factor;
       fprintf("[     computeTwist    ] trimming cmd_vel (%2.5f) -> cmd_vel = [%2.4f, %2.4f, %2.4f]\n", ...
            vel_shortening_factor, ...
            cmd_vel(1), ...
            cmd_vel(2), ...
            cmd_vel(3) ...
       );
    end
    
    % trim minimum velocity to `min_vel_x`
    if min_vel_x > cmd_vel(1)
        fprintf("[     computeTwist    ] trimming cmd_vel.x from %2.5f to %2.5f\n", ...
            cmd_vel(1), ...
            min_vel_x ...
        );
        cmd_vel(1) = min_vel_x;
    end
end
