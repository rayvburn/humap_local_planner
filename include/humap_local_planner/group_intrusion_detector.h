#pragma once

#include <humap_local_planner/group.h>
#include <humap_local_planner/obstacle_separation_cost_function.h>
#include <humap_local_planner/trajectory.h>

#include <utility>

namespace humap_local_planner {

class GroupIntrusionDetector {
public:
	// Struct used mostly for visualization purposes
	struct AltGoalCandidate {
		double x;
		double y;
		double cost;
		size_t id;

		AltGoalCandidate(double x, double y, double cost, size_t id = 0):
			x(x),
			y(y),
			cost(cost),
			id(id)
		{}
	};

	/**
	 * Minimum number of points that cross the O-space of the F-formation to consider a group as intruded by the robot
	 * Should not be less than 2 but lower than 10
	 */
	static constexpr int PTS_NUM_CROSSING_GROUP = 2;

	/// Number of alternative goal candidates on each side of the ellipse (compared to the initial crossing angle)
	static constexpr size_t ANGLE_CANDIDATES_SIDE = 20;

	/// Distance from the ellipse intersection to check for free poses along the line
	static constexpr double DIST_FROM_EDGE_MAX = 1.5;

	/// Divider of a @ref footprint_inflated_diameter_
	static constexpr double DIST_GRANULARITY_DIVIDER = 5.00;

	GroupIntrusionDetector();

	/**
	 * Updates the parameters used in the calculations
	 *
	 * @param footprint_inflated_diameter how much gap we require between obstacle points to allow robot movement
	 * @param recovery_point_distance_threshold minimum distance from the current pose to an intermediate goal
	 * for acceptance
	 */
	void setParameters(
		double footprint_inflated_diameter,
		double recovery_point_distance_threshold
	);

	/**
	 * @brief Performs intrusion detection and tries to find a safe pose for the robot to avoid crossing the group
	 *
	 * @param groups information about the surrounding groups
	 * @param global_plan transformed global plan (expressed in the same frame as the other parameters)
	 * @param global_goal goal pose in the global context (might not be the last pose of the @ref global_plan)
	 * @return true when intrusion was detected
	 */
	bool detect(
		const std::vector<Group>& groups,
		const std::vector<geometry_msgs::PoseStamped>& global_plan,
		const geometry_msgs::PoseStamped& global_goal
	);

	/**
	 * Using a heuristic algorithm, tries to find an alternative intermediate goal that aims to avoid group crossing
	 *
	 * @param global_plan transformed global plan (expressed in the same frame as the other parameters)
	 * @param obstacle_costfun evaluates whether placing a robot in given coordinates is collision-free
	 * @return true when any alternative goal(s) was/were found
	 * @return false
	 */
	bool planAlternativeGoal(
		const std::vector<geometry_msgs::PoseStamped>& global_plan,
		const ObstacleSeparationCostFunction& obstacle_costfun
	);

	inline bool isIntrusionDetected() const {
		return !groups_intersected_plan_.empty();
	}

	/// Whether the global goal is located inside the spatial model of the F-formation
	inline bool isGlobalGoalWithinGroup() const {
		return global_goal_within_group_;
	}

	inline double getDistanceToGroupGoalWithin() const {
		return global_goal_group_dist_;
	}

	inline double getDistanceToGroupEdgeGoalWithin() const {
		return global_goal_group_dist_edge_;
	}

	/// Returns alternative intermediate goals to avoid crossing of a group (obtained using a heuristic algorithm)
	/// @return each pair consists of a pose and a cost
	inline std::vector<std::pair<geometry::Pose, double>> getIntermediateGoalsAsPairs() const {
		return goal_alternatives_;
	}

	/// Returns alternative intermediate goals to avoid crossing of a group (obtained using a heuristic algorithm)
	std::vector<AltGoalCandidate> getIntermediateGoals() const;

	// Returns a container that is mostly used for visualization purposes
	inline const std::vector<AltGoalCandidate>& getIntermediateGoalCandidates() const {
		return goal_alternative_candidates_;
	}

	/**
	 * @brief Evaluates whether the point given by (x, y) lies within the ellipse described by the given parameters
	 *
	 * Implementation generated by the ChatGPT
	 *
	 * @param x x-coordinate of the point of interest
	 * @param y y-coordinate of the point of interest
	 * @param h x-coordinate of the center position of the ellipse
	 * @param k y-coordinate of the center position of the ellipse
	 * @param theta orientation of the ellipse
	 * @param a length of the semi-major axis of the ellipse
	 * @param b length of the semi-minor axis of the ellipse
	 */
	static bool checkPointInEllipse(
		double x,
		double y,
		double h,
		double k,
		double theta,
		double a,
		double b
	);

	/**
	 * @brief
	 *
	 * The implementation (ChatGPT-generated) is not perfect but finds the intersection points of rotated ellipses
	 * good enough.
	 *
	 * @param angle direction of the line starting at the center of the ellipse (in a global coordinate system)
	 * @param h x-coordinate of the center position of the ellipse
	 * @param k y-coordinate of the center position of the ellipse
	 * @param theta orientation of the ellipse
	 * @param a length of the semi-major axis of the ellipse
	 * @param b length of the semi-minor axis of the ellipse
	 * @return std::pair<double, double> coordinates of the intersection point
	 */
	static std::pair<double, double> findEllipseLineIntersection(
		double angle,
		double h,
		double k,
		double theta,
		double a,
		double b
	);

	/**
	 * @brief Calculates the relative location (left/right) of the point compared to the ellipse's major axis
	 *
	 * Implementation generated by the ChatGPT
	 *
	 * @param x x-coordinate of the point of interest
	 * @param y y-coordinate of the point of interest
	 * @param h x-coordinate of the center position of the ellipse
	 * @param k y-coordinate of the center position of the ellipse
	 * @param theta orientation of the ellipse
	 * @param a length of the semi-major axis of the ellipse
	 * @param b length of the semi-minor axis of the ellipse
	 * @return double
	 */
	static double findPointLocationInEllipse(
		double x,
		double y,
		double h,
		double k,
		double theta,
		double a,
		double b
	);

	/**
	 * @brief Calculates the angle between the vector u and the vector v
	 *
	 * @param u_x x-coordinate of the u vector
	 * @param u_y y-coordinate of the u vector
	 * @param v_x x-coordinate of the v vector
	 * @param v_y y-coordinate of the v vector
	 * @return double angle in radians: v is on the left of the u when the angle is positive; negative indicates right
	 */
	static double angleBetweenVectors(
		double u_x,
		double u_y,
		double v_x,
		double v_y
	);

protected:
	/// Helper class extending the standard Group (a.k.a. F-formation)
	class GroupInfo: public Group {
	public:
		GroupInfo(const Group& base, double cross_angle):
			Group(base),
			cross_angle_(cross_angle),
			cross_pts_left_(0),
			cross_pts_right_(0)
		{}

		void incrementCrossingPointsLeft() {
			cross_pts_left_++;
		}

		void incrementCrossingPointsRight() {
			cross_pts_right_++;
		}

		size_t getCrossingPointsLeft() const {
			return cross_pts_left_;
		}

		size_t getCrossingPointsRight() const {
			return cross_pts_right_;
		}

		double getCrossingAngle() const {
			return cross_angle_;
		}

	protected:
		double cross_angle_;
		size_t cross_pts_left_;
		size_t cross_pts_right_;
	};

	/**
	 * @brief Resets member variables related to the alternative goal that avoids intruding the O-space of F-formation
	 */
	void resetAlternativeGoal();

	// Stores goal alternatives found by the heuristic algorithm (a pair consists of a pose and a cost)
	std::vector<std::pair<geometry::Pose, double>> goal_alternatives_;

	bool global_goal_within_group_;
	/// Distance to the closest center of the spatial model of the group
	double global_goal_group_dist_;
	/// Distance to the closest point lying on the edge of the spatial model of the group
	double global_goal_group_dist_edge_;

	double footprint_inflated_diameter_;
	double recovery_point_distance_threshold_;

	std::vector<GroupInfo> groups_intersected_plan_;
	// Container with alternative goal candidates (only for visualization purposes)
	std::vector<AltGoalCandidate> goal_alternative_candidates_;
};

} // namespace humap_local_planner
