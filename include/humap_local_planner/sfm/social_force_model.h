/*
 * SocialForceModel.h
 *
 *  Created on: Dec 4, 2018
 *      Author: rayvburn
 */

#pragma once

#include <humap_local_planner/geometry/geometry.h>
#include <humap_local_planner/utils/shift_register.h>

// environment obstacle representation
#include <humap_local_planner/humap_config.h>
#include <humap_local_planner/world.h>

// C++ STL
#include <vector>	// closest points
#include <tuple>	// rel_loc
#include <chrono>

// ----------------------------------------------------------------------------------------------- //
/*
 * References:
 * 		- D. Helbing et al. 	- Social Force Model for Pedestrian Dynamics ‎(1998)
 * 		- Moussaid et al. 		- Experimental study of the behavioural mechanisms underlying
 * 		  						  self-organization in human crowds (2009)
 * 		- S. Seer et al. 		- Validating Social Force based Models with Comprehensive
 * 		  						  Real World Motion Data (2014)
 *
 * https://www.sciencedirect.com/science/article/pii/S2352146514001161
 * In the above paper there are results of the research presented. They point that
 * Model C (Rudloff et al. (2011) of SFM fits best the real world data.
 */
// ----------------------------------------------------------------------------------------------- //

namespace humap_local_planner {
namespace sfm {
using namespace geometry;

// ---------------------------------

typedef enum {

	/** `The repulsive force from static obstacles f αi is modeled by using the functional
	 * form as given by the repulsive force for elliptical formulation` - 2014 */
	INTERACTION_ELLIPTICAL = 0,		// a.k.a. v2014

	/** `repulsion from walls uses the same formulas as the repulsion from other
	 * pedestrians` - 2011 */
	INTERACTION_REPULSIVE_EVASIVE	// a.k.a. v2011

} StaticObjectInteraction;

// Which method will be used for FOV calculation
typedef enum : unsigned int {
	GAUSSIAN = 0,
	LINEAR = 1
} FovCalculationMethod;

// ---------------------------------

/** 	φ_αβ issue
 * There is an inconsistency in papers connected with the Rudloff's version of Social Force model -
 * in Rudloff et al. 2011 - https://www.researchgate.net/publication/236149039_Can_Walking_Behavior_Be_Predicted_Analysis_of_Calibration_and_Fit_of_Pedestrian_Models
 * there is a statement that theta_alpha_beta is an "angle between velocity of pedestrian α and the displacement of pedestrian β"
 * whereas in Seer et al. 2014 - https://www.sciencedirect.com/science/article/pii/S2352146514001161
 * they say that in this model "φ αβ is the angle between n α and d αβ" (they call it phi instead of theta)
 */

/** 	n_α issue
 * Another inconsistency between 2011 and 2014 papers connected to Rudloff's SFM version is n_alpha issue.
 * In 2011 original paper there is said that n_alpha is "pointing in the opposite direction to the walking
 * direction (deceleration force)".
 * On the other hand in 2014 paper (that Rudloff is co-author of) they say: "n α is the direction of movement
 * of pedestrian α".
 */

typedef enum {

	/** " φ_αβ is an angle between velocity of pedestrian α and the displacement of pedestrian β "
	 * " n_α is pointing in the opposite direction to the walking direction (deceleration force) "
	 *   2011 */
	PARAMETER_DESCRIPTION_2011 = 0,

	/** " φ_αβ is the angle between n_α and d_αβ "
	 * " n_α is the direction of movement of pedestrian α "
	 *   2014 */
	PARAMETER_DESCRIPTION_2014,

	/** Connected only with another φ_αβ angle description:
	 * NOTE: below method of calculating the angle is only correct when both objects are:
	 * 		o dynamic,
	 * 		o currently moving,
	 * 		o already aligned with the to-target-direction,
	 * 		o there are no obstacles in the environment that will make the object not move along a straight line.
	 * NOT RECOMMENDED */
	PARAMETER_DESCRIPTION_UNKNOWN

} ParameterDescription;

// ---------------------------------

/** Related to an issue connected with a case when actor's
 * direction is opposite to the resulting force direction.
 * Most likely occurs when actor is forced by an other
 * object to turn out of the way pointing towards his
 * target. The force generated by the algorithm in such
 * situation is usually so strong that causes actor
 * 3/4 rotation first and then he keeps trying to reach
 * the goal.
 * Opposite force threshold is 0.85 * PI. */
typedef enum {

	/** Despite of the force pulling actor in the opposite direction
	  * (relative to the current movement direction) he will
	  * still try to go towards his goal. */
	OPPOSITE_FORCE_GO_TOWARDS_GOAL,

	/**
	  * The force is pulling the actor in the opposite direction but
	  * he tries to rotate left. This prevents force oscillation effect
	  * to cast down onto the actor's behaviour.
	  * Letting the raw force to lead the actor will most likely
	  * cause some 'collision' because oscillations from 1 side
	  * to the other will lock any stronger rotations
	  * and actor will accelerate going straight ahead
	  * (yes, opposite to the SFM algorithm result).
	  */
	OPPOSITE_FORCE_ROTATE_LEFT

} OppositeForceMethod;

// ---------------------------------

class SocialForceModel {

public:

	/// \brief Default constructor
	SocialForceModel();

	/// \brief Function which sets internal parameters according to loaded parameters
	void init(std::shared_ptr<const humap_local_planner::SfmParams> cfg);

	/// \brief Updates internal parameters
	void setEquationParameters(
		double an,
		double bn,
		double cn,
		double ap,
		double bp,
		double cp,
		double aw,
		double bw
	);

	/// \brief Updates internal parameters
	void setEquationParameters(
		double an,
		double bn,
		double cn,
		double ap,
		double bp,
		double cp,
		double aw,
		double bw,
		double speed_desired
	);

	/// \brief Updates internal parameters
	void setEquationParameters(
		double an,
		double bn,
		double cn,
		double ap,
		double bp,
		double cp,
		double aw,
		double bw,
		double speed_desired,
		double relaxation_time
	);

	/// \brief Returns true if interaction forces were disabled in the provided config struct
	bool areInteractionForcesDisabled() const;

	/// \brief Function which calculates social force
	/// for an actor taking whole world's objects
	/// into consideration
	bool computeSocialForce(
			const World& world,
			const double &dt,
			std::vector<Distance>& meaningful_static,
			std::vector<Distance>& meaningful_dynamic
	);

	/// \brief Returns internal force vector
	inline Vector getForceInternal() const {
		return (force_internal_);
	}
	/// \brief Returns interaction force vector
	inline Vector getForceInteractionStatic() const {
		return (force_interaction_static_);
	}

	inline Vector getForceInteractionDynamic() const {
		return (force_interaction_dynamic_);
	}

	/// \brief Returns combined force vector (internal
	/// and interaction components summed up)
	inline Vector getForceCombined() const {
		return (force_combined_);
	}

	/**
	 * @defgroup eqnparams Equation parameter getters
	 * @{
	 */
	double getParameterAn() const {
		return An_;
	};

	double getParameterBn() const {
		return Bn_;
	};

	double getParameterCn() const {
		return Cn_;
	};

	double getParameterAp() const {
		return Ap_;
	};

	double getParameterBp() const {
		return Bp_;
	};

	double getParameterCp() const {
		return Cp_;
	};

	double getParameterAw() const {
		return Aw_;
	};

	double getParameterBw() const {
		return Bw_;
	};

	double getParameterDesiredSpeed() const {
		return speed_desired_;
	};

	double getParameterRelaxationTime() const {
		return relaxation_time_;
	};
	/// @} // end of eqnparams

	/// Given the @ref angle_relative and full FOV @ref fov, computes FOV factor applicable for interactions
	static double computeFactorFOV(double angle_relative, double fov, bool gaussian = true);

	/// \brief Default destructor
	virtual ~SocialForceModel() = default;

protected:

	/// \brief Helper function which assigns randomly
	/// generated numbers (with a proper mean and std. dev)
	/// to an algorithm parameters An, ... , Bw
	void setParameters();

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Social Force Model's components section (internal acceleration,
	// interaction force (dynamic/static) )

	/// \brief Helper function which calculates the internal force
	/// term of an actor; this component describes a person's
	/// motivation to reach its current goal
	Vector computeInternalForce(const Robot& robot);

	/// @ref computeInternalForce, static, parameterized version created for unit testing
	static Vector computeInternalForce(const Vector& vel_robot, const Vector& d_robot_object, const double& mass, const double& speed_desired, const double& relaxation_time);

	/// \brief Helper function which calculates interaction
	/// force which another object (static or dynamic)
	/// exerts on the actor (tuple's first element).
	/// Additionally, a distance vector to the currently
	/// considered obstacle is returned as the tuple's second
	/// element. Third element is a length of that vector.
	Vector computeInteractionForce(const Robot& robot, const DynamicObject& object); // TODO: const?

	/// \brief Helper function which computes a repulsive
	/// force which static obstacle exerts on the actor;
	/// fits 2014 configuration and used only in this case.
	Vector computeInteractionForce(const Robot& robot, const StaticObject& object, const double &dt);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Section covering more of a geometry-related functions
	/* Theta alpha-beta calculation */

	/// \brief Helper function which computes theta_αβ angle;
	/// fits 2011 configuration, where this angle is defined
	/// as: "an angle between velocity of pedestrian α and
	/// the displacement of pedestrian β"
	static Angle computeThetaAlphaBetaAngle2011(const Vector& robot_vel, const Vector& object_vel);

	/// \brief Helper function which computes theta_αβ angle;
	/// fits 2014 configuration, where this angle is defined
	/// as: "an angle between n_α and d_αβ"
	/// \[param in] n_alpha - actor's normal (based on velocity
	/// vector)
	/// \[param in] d_alpha_beta - vector between objects
	/// positions
	static Angle computeThetaAlphaBetaAngle2014(const Vector& n_alpha, const Vector& d_alpha_beta);

	/// \brief Helper function which computes theta_αβ angle;
	/// works only for dynamically moving actors -
	/// NOT RECOMMENDED
	static Angle computeThetaAlphaBetaAngle(const Angle& actor_yaw, const Angle& object_yaw);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	/* Resultative vector components calculation - normal (n_alpha)
	 * and perpendicular (p_alpha) */

	/// \brief Helper function which computes a vector
	/// that is normal to alpha's direction vector;
	/// depending on the `parameter description` set
	/// the vector is calculated differently
	Vector computeNormalAlphaDirection(const Pose &actor_pose);

	/// @ref computeNormalAlphaDirection, static, parameterized version created for unit testing
	static Vector computeNormalAlphaDirection(const Angle &robot_yaw, ParameterDescription param_description);

	/// \brief Helper function which takes a given n_alpha
	/// vector and based on currently investigated object's
	/// relative to the actor location calculates a perpendicular
	/// to n_alpha vector
	Vector computePerpendicularToNormal(const Vector &n_alpha,
			const RelativeLocation &beta_rel_location);

	/// @ref computePerpendicularToNormal, static, parameterized version created for unit testing
	static Vector computePerpendicularToNormal(
			const Vector &n_alpha,
			const RelativeLocation &beta_rel_location,
			ParameterDescription param_description
	);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	/* General functions section (still geometry-related) */
	/// \brief Helper function which checks whether a given
	/// angle is within actor's field of view bounds
	inline bool isOutOfFOV(const Angle& angle_relative);

	/// Computes FOV factor applicable for interactions
	inline double computeFactorFOV(const Angle& angle_relative);

	/// \brief Helper function which calculates relative
	/// speed based on 2 given velocity vectors
	/// \details It assigns 0 to Z component of the vector (in case rotational velocity is stored there)
	static double computeRelativeSpeed(const Vector& actor_vel, const Vector& object_vel);

	/// \brief Multiplies force components by a factor parameters
	/// and computes the combined force vector (summation).
	/// \note See \ref multiplyForces
	void factorInForceCoefficients();

	/// \brief Extends/truncates forces vectors if needed (i.e. combined force's
	/// magnitude too big / too small)
	/// \param dist_closest_static: distance to the closest static obstacle available
	/// \param dist_closest_dynamic: distance to the closest dynamic obstacle available
	void applyNonlinearOperations(const double &dist_closest_static, const double &dist_closest_dynamic);

	/// \brief Multiplies all force components (i.e. internal, interaction and social)
	/// by a given coefficient and updates the total force (`force_combined_`)
	/// according to a sum of components.
	/// \param coefficient: factor
	/// \note Truncates/extends all forces and calculates the combined one
	/// \note Non-linear operation
	void multiplyForces(const double &coefficient);

	/// \brief Resets class' internal state - forces
	void reset();

	/// Sums up all force components that produce combined force
	void computeCombinedForce();

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	/// \brief ShiftRegister is used for smoothing social force
	/// especially in close presence of the obstacles where most
	/// likely there is a highly weakened potential field.
	/// This in turn can cause a very difference force vector
	/// direction in 2 consecutive iterations.
	/// \note This saves only each `Arg2`-th sample and stores `Arg1` samples
	ShiftRegister<Vector> sf_values_{1, 0};

	/// \section Section: Force vectors section
	///
	/// \brief Internal force vector (a.k.a. f_alpha)
	Vector force_internal_;
	///
	/// \brief Interaction force vector created from
	/// a set of single interactions from dynamic
	/// obstacles (a.k.a sum of f_alpha_beta's)
	Vector force_interaction_dynamic_;
	/// \brief Interaction force vector created from
	/// a set of single interactions from static and dynamic
	/// obstacles
	Vector force_interaction_static_;

	///
	/// \brief Result of summation of internal
	/// and interaction force vectors.
	Vector force_combined_;

	/// \section Section: Social Force Model parameters
	///
	/// \brief Relaxation time
	float relaxation_time_;
	///
	/// \brief Desired speed
	float speed_desired_;

	/// \section Section: SFM parameters
	/// \note substitute for a lot of parameters
	std::shared_ptr<const humap_local_planner::SfmParams> cfg_;

	///
	/// \brief Related to an inconsistency in symbols
	/// presented in the papers, see \ref ParameterDescription
	sfm::ParameterDescription param_description_;

	/* Model C -> Rudloff et al. (2011) model's parameters based on  S. Seer et al. (2014) */
	/* setting parameters static will create a population of actors moving in the same way */
	// TODO: make all actors share the same param values
	float An_;
	float Bn_;
	float Cn_;
	float Ap_;
	float Bp_;
	float Cp_;
	float Aw_;
	float Bw_;
};

} /* namespace sfm */
} /* namespace humap_local_planner */
