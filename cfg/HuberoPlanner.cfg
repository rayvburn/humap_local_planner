#!/usr/bin/env python
# HuBeRo Planner configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params

# http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile
gen = ParameterGenerator()

# This unusual line allows to reuse existing parameter definitions that concern all localplanners
group_limits = gen.add_group("Limits", type="tab")
add_generic_localplanner_params(group_limits)

#
group_general = gen.add_group("General", type="tab")

group_general.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 1.7, 0)
group_general.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.025, 0)
group_general.add("angular_sim_granularity", double_t, 0, "The granularity with which to check for collisions for rotations in radians", 0.1, 0)
group_general.add("sim_period", double_t, 0, "How often planning executes", 1.7, 0)
group_general.add("forward_point_distance", double_t, 0, "The distance from the center point of the robot to place a local goal", 0.5, 0.25, 2.0)
# TODO: add to limits group
group_general.add("twist_rotation_compensation", double_t, 0, "Defines how much robot tries to follow force direction compared to pure transformation of force into local velocity", 0.25, 0.0, 2.0)

# SFM group parameters
group_sfm = gen.add_group("SFM", type="tab")

group_sfm.add("fov", double_t, 0, "Field of view of the robot", 2.00, 0.0, +3.14)
group_sfm.add("max_speed", double_t, 0, "maximum speed", 1.50, 0.00, 2.50)
group_sfm.add("mass", double_t, 0, "Description", 14.5, 0.1, 250.0) # 20.0
group_sfm.add("maneuverability", double_t, 0, "Description", 0.0065, 0.002, 0.010)
group_sfm.add("internal_force_factor", double_t, 0, "Description", 12.0, 0.0, 50.0) # 1.5
group_sfm.add("interaction_force_factor", double_t, 0, "Description", 36.0, 0.0, 75.0) # 15.0
group_sfm.add("min_force", double_t, 0, "Description", 5.0, 0.0, 100.0) # 1.0
group_sfm.add("max_force", double_t, 0, "Description", 250.0, 0.0, 500.0) # 100.0

soi_enum = gen.enum([ gen.const("elliptical",      	int_t, 0, "a.k.a. v2014"),
                       gen.const("repulsive_evasive",	int_t, 1, "a.k.a. v2011")],
                     "Static Object Interaction")
group_sfm.add("static_object_interaction_type", int_t, 0, "Description", 0, 0, 1, edit_method=soi_enum)

boxi_enum = gen.enum([ gen.const("box_other_objects",	int_t, 0, "Specify"),
                       gen.const("box_all_objects",	int_t, 1, "Specify"),
                       gen.const("circle",				int_t, 2, "Specify"),
                       gen.const("ellipse",				int_t, 3, "Specify"),
                       gen.const("none",				int_t, 4, "Specify")],
                     "Inflation Type")
group_sfm.add("inflation_type", int_t, 0, "Description", 3, 0, 4, edit_method=boxi_enum)

ofm_enum = gen.enum([ gen.const("go_towards_goal",	int_t, 0, "Specify"),
                      gen.const("rotate_left",		int_t, 1, "Specify")],
                     "Opposite Force Method")
group_sfm.add("oppsite_force_method", int_t, 0, "Description", 0, 0, 1, edit_method=ofm_enum)
group_sfm.add("disable_interaction_forces", bool_t, 0, "Description", False)

# Behaviour group parameters
group_beh = gen.add_group("Behaviour", type="tab")

group_beh.add("force_factor", double_t, 0, "Description", 1.0, 0.0, 10.0)
group_beh.add("turn_left", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("turn_left_accelerate_turn", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("turn_left_accelerate_acc", double_t, 0, "Description", 625.0, 0.0, 1000.0)
group_beh.add("accelerate", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("turn_right_accelerate_turn", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("turn_right_accelerate_acc", double_t, 0, "Description", 625.0, 0.0, 1000.0)
group_beh.add("turn_right", double_t, 0, "Description", 800.0, 0.0, 1500.0)
group_beh.add("turn_right_decelerate_turn", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("turn_right_decelerate_dec", double_t, 0, "Description", 625.0, 0.0, 1000.0)
group_beh.add("stop", double_t, 0, "Description", 500.0, 0.0, 1000.0)
group_beh.add("decelerate", double_t, 0, "Description", 500.0, 0.0, 1000.0)

# Trajectory generation group parameters
group_traj = gen.add_group("Trajectory", type="tab")

group_traj.add("planning_approach", bool_t, 0, "Whether to use planning (True) or proactive approach (False) for trajectory generation", True)

group_traj.add("force_internal_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_internal_amplifier_max", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_internal_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

group_traj.add("force_interaction_dynamic_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_dynamic_amplifier_max", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_dynamic_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

group_traj.add("force_interaction_social_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_social_amplifier_max", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_social_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

group_traj.add("force_interaction_static_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_static_amplifier_max", double_t, 0, "Description", 0.0, 0.0, 5.0)
group_traj.add("force_interaction_static_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

# Other
gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration.", False)

exit(gen.generate("hubero_local_planner", "hubero_local_planner", "HuberoPlanner"))
