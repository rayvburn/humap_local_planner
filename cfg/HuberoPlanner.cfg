#!/usr/bin/env python
# HuBeRo Planner configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params

# http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile
gen = ParameterGenerator()

# This unusual line allows to reuse existing parameter definitions that concern all localplanners
group_limits = gen.add_group("Limits", type="tab")
group_limits_generic_lp = group_limits.add_group("BaseLocalPlanner", type="hide")
add_generic_localplanner_params(group_limits_generic_lp)
group_limits_custom = group_limits.add_group("Custom", type="hide")
group_limits_custom.add("twist_rotation_compensation", double_t, 0, "Defines how much robot tries to additionally follow force direction compared to pure transformation of force into local velocity. This is related to experimental twist computation heuristics that strains vector field assumptions.", 0.0, 0.0, 2.0)

#
group_general = gen.add_group("General", type="tab")

group_general.add("planning_approach", bool_t, 0, "Whether to use planning (True) or proactive approach (False) for trajectory generation", True)
group_general.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 2.0, 0)
group_general.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.2, 0)
group_general.add("angular_sim_granularity", double_t, 0, "The granularity with which to check for collisions for rotations in radians", 0.1, 0)
group_general.add("local_goal_distance", double_t, 0, "The distance from the center point of the robot to place a local goal. Try to keep it below 0.5 m for proactive approach. Must not exceed local costmap bounds.", 1.0, 0.25, 3.0)
group_general.add("obstacle_extension_multiplier", double_t, 0, "The factor by which robot's inscribed radius will be multiplied to caluclate distance between closest points of the robot footprint and environment object (static/dynamic)", 0.0, 0.0, 2.0)
group_general.add("person_model_radius", double_t, 0, "The radius of the circular representation of person-obstacle used by the sparse environment model", 0.4, 0.0, 2.0)
group_general.add("person_fov", double_t, 0, "Half of the field of view of a detected person", 3.31613 / 2.0, 0.0, +3.1415)
group_general.add("publish_traj_pcl", bool_t, 0, "Whether to publish PCL with explored trajectories", True)
group_general.add("publish_cost_grid_pcl", bool_t, 0, "Whether to publish PCL with the potential field generated by the cost function", True)

# SFM group parameters
group_sfm = gen.add_group("SFM", type="tab")

group_sfm.add("fov", double_t, 0, "Half of the field of view of the robot", 2.00, 0.0, +3.14)
group_sfm.add("mass", double_t, 0, "Description", 14.5, 0.1, 250.0)
group_sfm.add("internal_force_factor", double_t, 0, "How much robot tries to reach the goal position using shortest path to goal. For non-planning approach keep it at approx. 4.2", 0.75, 0.0, 50.0)
group_sfm.add("static_interaction_force_factor", double_t, 0, "How much robot tries to maintain safe distance from static obstacles. For non-planning approach keep it at approx. 11.0", 4.9, 0.0, 300.0)
group_sfm.add("dynamic_interaction_force_factor", double_t, 0, "How much robot tries to maintain safe distance from dynamic obstacles", 1.0, 0.0, 300.0)
group_sfm.add("min_force", double_t, 0, "Minimum force - vectors shorter than that will be extended, which may prevent from being stuck.", 5.0, 0.0, 100.0)
group_sfm.add("max_force", double_t, 0, "Maximum force - vectors longer than that will be truncated", 300.0, 0.0, 1500.0)
group_sfm.add("heterogenous_population", bool_t, 0, "Setting true causes SFM params to be defined in non-deterministic way (std deviation around mean value)", False)
soi_enum = gen.enum([ gen.const("elliptical",      	int_t, 0, "a.k.a. v2014"),
                       gen.const("repulsive_evasive",	int_t, 1, "a.k.a. v2011")],
                     "Static Object Interaction")
group_sfm.add("static_object_interaction_type", int_t, 0, "Description", 0, 0, 1, edit_method=soi_enum)
group_sfm.add("disable_interaction_forces", bool_t, 0, "Description", False)

group_param_eqn_mean = group_sfm.add_group("EquationParams", type="hide")
group_param_eqn_mean.add("an", double_t, 0, "Default multiplier: -8.0", -8.0 * 0.2615, -300.0, +300.0)
group_param_eqn_mean.add("bn", double_t, 0, "Default multiplier: +5.0", +5.0 * 0.4026, -300.0, +300.0)
group_param_eqn_mean.add("cn", double_t, 0, "Default multiplier: +1.5", +1.5 * 2.1614, -300.0, +300.0)
group_param_eqn_mean.add("ap", double_t, 0, "Default multiplier: +1.0", +1.0 * 1.5375, -300.0, +300.0)
group_param_eqn_mean.add("bp", double_t, 0, "Default multiplier: +2.0", +2.0 * 0.4938, -300.0, +300.0)
group_param_eqn_mean.add("cp", double_t, 0, "Default multiplier: +0.8", +0.8 * 0.5710, -300.0, +300.0)
group_param_eqn_mean.add("aw", double_t, 0, "Default multiplier: +123.139", +123.139 * 0.3280, -300.0, +300.0)
group_param_eqn_mean.add("bw", double_t, 0, "Default multiplier: +1.2", +1.2 * 0.1871, -300.0, +300.0)
group_param_eqn_mean.add("speed_desired", double_t, 0, "Default: 1.29", 1.29, 0.0, 3.0)
group_param_eqn_mean.add("relaxation_time", double_t, 0, "Default: 0.54", 0.54, 0.0, 3.0)

group_param_eqn_stddev = group_sfm.add_group("EquationParamsStdDev", type="hide")
group_param_eqn_stddev.add("an_stddev", double_t, 0, "", 0.0551, -300.0, +300.0)
group_param_eqn_stddev.add("bn_stddev", double_t, 0, "", 0.1238, -300.0, +300.0)
group_param_eqn_stddev.add("cn_stddev", double_t, 0, "", 0.3728, -300.0, +300.0)
group_param_eqn_stddev.add("ap_stddev", double_t, 0, "", 0.3084, -300.0, +300.0)
group_param_eqn_stddev.add("bp_stddev", double_t, 0, "", 0.1041, -300.0, +300.0)
group_param_eqn_stddev.add("cp_stddev", double_t, 0, "", 0.1409, -300.0, +300.0)
group_param_eqn_stddev.add("aw_stddev", double_t, 0, "", 0.1481, -300.0, +300.0)
group_param_eqn_stddev.add("bw_stddev", double_t, 0, "", 0.0563, -300.0, +300.0)
group_param_eqn_stddev.add("speed_desired_stddev", double_t, 0, "", 0.19, -300.0, +300.0)
group_param_eqn_stddev.add("relaxation_time_stddev", double_t, 0, "", 0.05, -300.0, +300.0)

# Fuzzy Inference System group parameters
group_fis = gen.add_group("FIS", type="tab")

group_fis.add("force_factor", double_t, 0, "Factor to multiply resultant human action force with", 30.0, 0.0, 100.0)
group_fis.add("human_action_range", double_t, 0, "Distance at which any human action force fade completely", 8.0, 0.0, 10.0)
group_fis.add("as", double_t, 0, "Levelling factor that also directly affects amplitude of the resultant force", 1.1865, 0.0, 10.0)

# Equisampled trajectory generation group parameters
group_traj_gen = gen.add_group("TrajectoryGeneration", type="tab")
group_traj_gen.add("use_equisampled_velocities_generator", bool_t, 0, "True enables generator that produces evenly spaced elements from a list of feasible velocities", True)
group_traj_gen.add("equisampled_vx", int_t, 0, "How many velocity samples along platform's X axis will be checked", 3, 0, 40)
group_traj_gen.add("equisampled_vy", int_t, 0, "How many velocity samples along platform's Y axis will be checked", 1, 0, 40)
group_traj_gen.add("equisampled_vth", int_t, 0, "How many velocity samples around platform's Z axis will be checked", 10, 0, 40)
group_traj_gen.add("equisampled_min_vel_x", double_t, 0, "Minimum linear velocity that is used by the equisampled velocities generator", 0.10, -0.5, 3.0)

# Trajectory sampling group parameters
group_traj_social = gen.add_group("TrajectorySocial", type="tab")
group_traj_social_speed = group_traj_social.add_group("SpeedDesired", type="hide")
group_traj_social_speed.add("sfm_desired_speed_amplifier_min", double_t, 0, "", 0.0, -300.0, +300.0)
group_traj_social_speed.add("sfm_desired_speed_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_speed.add("sfm_desired_speed_amplifier_granularity", double_t, 0, "", 0.5, -300.0, +300.0)
group_traj_social_an = group_traj_social.add_group("An", type="hide")
group_traj_social_an.add("sfm_an_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_an.add("sfm_an_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_an.add("sfm_an_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_bn = group_traj_social.add_group("Bn", type="hide")
group_traj_social_bn.add("sfm_bn_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_bn.add("sfm_bn_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_bn.add("sfm_bn_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_cn = group_traj_social.add_group("Cn", type="hide")
group_traj_social_cn.add("sfm_cn_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_cn.add("sfm_cn_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_cn.add("sfm_cn_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_ap = group_traj_social.add_group("Ap", type="hide")
group_traj_social_ap.add("sfm_ap_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_ap.add("sfm_ap_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_ap.add("sfm_ap_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_bp = group_traj_social.add_group("Bp", type="hide")
group_traj_social_bp.add("sfm_bp_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_bp.add("sfm_bp_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_bp.add("sfm_bp_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_cp = group_traj_social.add_group("Cp", type="hide")
group_traj_social_cp.add("sfm_cp_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_cp.add("sfm_cp_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_cp.add("sfm_cp_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)
group_traj_social_aw = group_traj_social.add_group("Aw", type="hide")
group_traj_social_aw.add("sfm_aw_amplifier_min", double_t, 0, "", -1.0, -300.0, +300.0)
group_traj_social_aw.add("sfm_aw_amplifier_max", double_t, 0, "", +1.0, -300.0, +300.0)
group_traj_social_aw.add("sfm_aw_amplifier_granularity", double_t, 0, "", 0.5, 0.0, +300.0)
group_traj_social_bw = group_traj_social.add_group("Bw", type="hide")
group_traj_social_bw.add("sfm_bw_amplifier_min", double_t, 0, "", -0.5, -300.0, +300.0)
group_traj_social_bw.add("sfm_bw_amplifier_max", double_t, 0, "", 2.5, -300.0, +300.0)
group_traj_social_bw.add("sfm_bw_amplifier_granularity", double_t, 0, "", 0.5, 0.0, +300.0)
group_traj_social_as = group_traj_social.add_group("As", type="hide")
group_traj_social_as.add("fis_as_amplifier_min", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_as.add("fis_as_amplifier_max", double_t, 0, "", 1.0, -300.0, +300.0)
group_traj_social_as.add("fis_as_amplifier_granularity", double_t, 0, "", 1.0, 0.0, +300.0)

# Trajectory generation group parameters
group_cost = gen.add_group("Cost", type="tab")

group_cost.add("path_distance_scale", double_t, 0, "The weight for the path distance part of the cost function", 1.5, 0.0)
group_cost.add("goal_distance_scale", double_t, 0, "The weight for the goal distance part of the cost function", 8.8, 0.0)
group_cost.add("occdist_scale", double_t, 0, "The weight for the obstacle distance part of the cost function", 0.2, 0.0)
group_cost.add("alignment_scale", double_t, 0, "The weight for the alignment with the global plan. In a classical DWA implementation equal to `path_distance_scale`", 1.4, 0.0)
group_cost.add("goal_front_scale", double_t, 0, "The weight for the achievement of the additional goal point placed in front of the mobile base. In a classical DWA implementation equal to `goal_distance_scale`", 0.0, 0.0)
group_cost.add("backward_scale", double_t, 0, "The weight for the backward motion penalisation", 0.08, 0.0)
group_cost.add("ttc_scale", double_t, 0, "The weight for the time to collision cost function (scores whole trajectory instead of a single cell)", 3.0, 0.0)
group_cost.add("chc_scale", double_t, 0, "The weight for the cost function that penalizes robot heading changes", 11.0, 0.0)
group_cost.add("speedy_goal_scale", double_t, 0, "The weight for the cost function that penalizes high speeds near global goal", 0.2, 0.0)
group_cost.add("velocity_smoothness_scale", double_t, 0, "The weight for the cost function that penalizes velocity changes along trajectory", 15.0, 0.0)
group_cost.add("contextualized_costs_scale", double_t, 0, "The weight for the cost function that penalizes trajectories based on contexts embedded into costmap", 0.06, 0.0)
group_cost.add("disturbance_scale", double_t, 0, "The weight for the cost function that penalizes trajectories that people may find disturbing", 7.0, 0.0)

group_cost.add("oscillation_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 0.05, 0.0)
group_cost.add("oscillation_reset_angle", double_t, 0, "The angle the robot must turn before oscillation flags are reset, in radians", 0.2, 0.0)

group_cost.add("scaling_speed", double_t, 0, "The absolute value of the velocity at which to start scaling the robot's footprint, in m/s", 0.25, 0.0)
group_cost.add("max_scaling_factor", double_t, 0, "The maximum factor to scale the robot's footprint by", 0.2, 0.0)
group_cost.add("backward_penalty", double_t, 0, "Penalty (cost) value assigned to trajectory that starts with backward motion", 25.0, 0.0)

group_cost.add("ttc_rollout_time", double_t, 0, "The duration of maximum world state prediction to detect robot collision (further beyond `sim_time`)", 1.5, 0.0)
group_cost.add("ttc_collision_distance", double_t, 0, "The distance threshold for collision detection in TTC prediction", 0.015, 0.0)

group_cost.add("forward_point_distance", double_t, 0, "The distance from the center point of the robot to place an additional scoring point, in meters", 0.325, 0.1, 2.0)
group_cost.add("speedy_goal_distance", double_t, 0, "The distance threshold of penalization of high speeds near global goal", 0.85, 0.0)

group_cost.add("disturbance_spatial_exp_factor", double_t, 0, "Multiplier of the exponent of the spatial factor of disturbance costs", -0.8, -10.0, 0.0)

# Diagnostics
group_diagnostics = gen.add_group("Diagnostics", type="tab")
group_diagnostics.add("log_trajectory_generation_samples", bool_t, 0, "Whether to print info on samples used for trajectory generation", False)
group_diagnostics.add("log_trajectory_generation_details", bool_t, 0, "Whether to print info on motion drivers (forces) of a specific trajectory", False)
group_diagnostics.add("log_trajectory_generation_fails", bool_t, 0, "Whether to print info on unsuccessful attempt to trajectory generation", False)
group_diagnostics.add("log_explored_trajectories", bool_t, 0, "Whether to print info on explored trajectories", False)
group_diagnostics.add("log_pts_of_explored_trajectories", bool_t, 0, "Whether to print info on points of explored trajectories", False)
group_diagnostics.add("log_trajectory_cost_details", bool_t, 0, "Whether to print info on cost of the best trajectory", False)
group_diagnostics.add("force_robot_stop", bool_t, 0, "Whether to force stoppage of robot without disabling planning (useful for cost tuning)", False)

# Other
gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration.", False)

exit(gen.generate("hubero_local_planner", "hubero_local_planner", "HuberoPlanner"))
