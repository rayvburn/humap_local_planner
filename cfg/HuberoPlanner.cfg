#!/usr/bin/env python
# HuBeRo Planner configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params

# http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile
gen = ParameterGenerator()

# This unusual line allows to reuse existing parameter definitions that concern all localplanners
group_limits = gen.add_group("Limits", type="tab")
group_limits_generic_lp = group_limits.add_group("BaseLocalPlanner", type="hide")
add_generic_localplanner_params(group_limits_generic_lp)
group_limits_custom = group_limits.add_group("Custom", type="hide")
group_limits_custom.add("twist_rotation_compensation", double_t, 0, "Defines how much robot tries to follow force direction compared to pure transformation of force into local velocity", 0.25, 0.0, 2.0)

#
group_general = gen.add_group("General", type="tab")

group_general.add("planning_approach", bool_t, 0, "Whether to use planning (True) or proactive approach (False) for trajectory generation", True)
group_general.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 1.8, 0)
group_general.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.085, 0)
group_general.add("angular_sim_granularity", double_t, 0, "The granularity with which to check for collisions for rotations in radians", 0.1, 0)
group_general.add("local_goal_distance", double_t, 0, "The distance from the center point of the robot to place a local goal. Try to keep it below 0.5 m for proactive approach", 1.0, 0.25, 3.0)
group_general.add("obstacle_extension_multiplier", double_t, 0, "The factor by which robot's inscribed radius will be multiplied to caluclate distance between closest points of the robot footprint and environment object (static/dynamic)", 1.0, 0.0, 2.0)
group_general.add("person_model_radius", double_t, 0, "The radius of the circular representation of person-obstacle used by the sparse environment model", 0.4, 0.0, 2.0)
group_general.add("publish_traj_pcl", bool_t, 0, "Whether to publish PCL with explored trajectories", True)
group_general.add("publish_cost_grid_pcl", bool_t, 0, "Whether to publish PCL with the potential field generated by the cost function", True)

# SFM group parameters
group_sfm = gen.add_group("SFM", type="tab")

group_sfm.add("fov", double_t, 0, "Field of view of the robot", 2.00, 0.0, +3.14)
group_sfm.add("mass", double_t, 0, "Description", 14.5, 0.1, 250.0)
group_sfm.add("internal_force_factor", double_t, 0, "How much robot tries to reach the goal position using shortest path to goal. For non-planning approach keep it at approx. 4.2", 4.2, 0.0, 50.0)
group_sfm.add("static_interaction_force_factor", double_t, 0, "How much robot tries to maintain safe distance from static obstacles. For non-planning approach keep it at approx. 11.0", 50.0, 0.0, 300.0)
group_sfm.add("dynamic_interaction_force_factor", double_t, 0, "How much robot tries to maintain safe distance from dynamic obstacles", 1.0, 0.0, 300.0)
group_sfm.add("min_force", double_t, 0, "Minimum force - vectors shorter than that will be extended, which may prevent from being stuck.", 5.0, 0.0, 100.0)
group_sfm.add("max_force", double_t, 0, "Maximum force - vectors longer than that will be truncated", 300.0, 0.0, 1500.0)
group_sfm.add("heterogenous_population", bool_t, 0, "Setting true causes SFM params to be defined in non-deterministic way (std deviation around mean value)", False)
group_sfm.add("use_tuned_params", bool_t, 0, "Whether to apply SFM parameter adjustments appointed in the tuning process", True)
soi_enum = gen.enum([ gen.const("elliptical",      	int_t, 0, "a.k.a. v2014"),
                       gen.const("repulsive_evasive",	int_t, 1, "a.k.a. v2011")],
                     "Static Object Interaction")
group_sfm.add("static_object_interaction_type", int_t, 0, "Description", 0, 0, 1, edit_method=soi_enum)
group_sfm.add("disable_interaction_forces", bool_t, 0, "Description", False)

# Fuzzy Inference System group parameters
group_fis = gen.add_group("FIS", type="tab")

group_fis.add("force_factor", double_t, 0, "Factor to multiply resultant human action force with", 30.0, 0.0, 100.0)
group_fis.add("human_action_range", double_t, 0, "Distance at which any human action force fade completely", 8.0, 0.0, 10.0)
group_fis.add("as", double_t, 0, "Levelling factor that also directly affects amplitude of the resultant force", 1.1865, 0.0, 10.0)

# Trajectory generation group parameters
group_traj = gen.add_group("Trajectory", type="tab")
group_generator_internal = group_traj.add_group("Internal", type="hide")
group_generator_internal.add("force_internal_amplifier_min", double_t, 0, "Description", 0.12, 0.0, 10.0)
group_generator_internal.add("force_internal_amplifier_max", double_t, 0, "Bigger value may provide higher speeds and may help with stucks at cluttered areas", 2.12, 0.0, 10.0)
group_generator_internal.add("force_internal_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 0.2, 0.0, 10.0)
group_generator_dynamic = group_traj.add_group("DynamicObject", type="hide")
group_generator_dynamic.add("force_interaction_dynamic_amplifier_min", double_t, 0, "Description", 0.25, 0.0, 10.0)
group_generator_dynamic.add("force_interaction_dynamic_amplifier_max", double_t, 0, "Description", 0.25, 0.0, 10.0)
group_generator_dynamic.add("force_interaction_dynamic_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)
group_generator_social = group_traj.add_group("HumanBehaviour", type="hide")
group_generator_social.add("force_interaction_social_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 10.0)
group_generator_social.add("force_interaction_social_amplifier_max", double_t, 0, "Description", 2.0, 0.0, 10.0)
group_generator_social.add("force_interaction_social_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)
group_generator_static = group_traj.add_group("StaticObject", type="hide")
group_generator_static.add("force_interaction_static_amplifier_min", double_t, 0, "Description", 0.025, 0.0, 10.0)
group_generator_static.add("force_interaction_static_amplifier_max", double_t, 0, "Description", 3.275, 0.0, 10.0)
group_generator_static.add("force_interaction_static_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 0.65, 0.0, 10.0)

# Trajectory generation group parameters
group_cost = gen.add_group("Cost", type="tab")

group_cost.add("path_distance_scale", double_t, 0, "The weight for the path distance part of the cost function", 0.6, 0.0)
group_cost.add("goal_distance_scale", double_t, 0, "The weight for the goal distance part of the cost function", 0.8, 0.0)
group_cost.add("occdist_scale", double_t, 0, "The weight for the obstacle distance part of the cost function", 0.01, 0.0)
group_cost.add("ttc_scale", double_t, 0, "The weight for the time to collision cost function (scores whole trajectory instead of a single cell)", 3.0, 0.0)
group_cost.add("chc_scale", double_t, 0, "The weight for the cost function that penalizes robot heading changes", 1.0, 0.0)
group_cost.add("speedy_goal_scale", double_t, 0, "The weight for the cost function that penalizes high speeds near global goal", 12.0, 0.0)

group_cost.add("oscillation_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 0.05, 0.0)
group_cost.add("oscillation_reset_angle", double_t, 0, "The angle the robot must turn before oscillation flags are reset, in radians", 0.2, 0.0)

group_cost.add("scaling_speed", double_t, 0, "The absolute value of the velocity at which to start scaling the robot's footprint, in m/s", 0.25, 0.0)
group_cost.add("max_scaling_factor", double_t, 0, "The maximum factor to scale the robot's footprint by", 0.2, 0.0)

group_cost.add("ttc_rollout_time", double_t, 0, "The duration of maximum world state prediction to detect robot collision (further beyond `sim_time`)", 1.5, 0.0)
group_cost.add("ttc_collision_distance", double_t, 0, "The distance threshold for collision detection in TTC prediction", 0.05, 0.0)

group_cost.add("forward_point_distance", double_t, 0, "The distance from the center point of the robot to place an additional scoring point, in meters", 0.325, 0.1, 2.0)
group_cost.add("speedy_goal_distance", double_t, 0, "The distance threshold of penalization of high speeds near global goal", 0.85, 0.0)

# Diagnostics
group_diagnostics = gen.add_group("Diagnostics", type="tab")
group_diagnostics.add("log_trajectory_generation_samples", bool_t, 0, "Whether to print info on samples used for trajectory generation", False)
group_diagnostics.add("log_trajectory_generation_details", bool_t, 0, "Whether to print info on motion drivers (forces) of a specific trajectory", False)
group_diagnostics.add("log_trajectory_generation_fails", bool_t, 0, "Whether to print info on unsuccessful attempt to trajectory generation", False)
group_diagnostics.add("log_explored_trajectories", bool_t, 0, "Whether to print info on explored trajectories", False)
group_diagnostics.add("log_pts_of_explored_trajectories", bool_t, 0, "Whether to print info on points of explored trajectories", False)
group_diagnostics.add("log_trajectory_cost_details", bool_t, 0, "Whether to print info on cost of the best trajectory", False)

# Other
gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration.", False)

exit(gen.generate("hubero_local_planner", "hubero_local_planner", "HuberoPlanner"))
