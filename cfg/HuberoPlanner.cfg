#!/usr/bin/env python
# HuBeRo Planner configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params

# http://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile
gen = ParameterGenerator()

# This unusual line allows to reuse existing parameter definitions that concern all localplanners
group_limits = gen.add_group("Limits", type="tab")
add_generic_localplanner_params(group_limits)
group_limits.add("twist_rotation_compensation", double_t, 0, "Defines how much robot tries to follow force direction compared to pure transformation of force into local velocity", 0.25, 0.0, 2.0)

#
group_general = gen.add_group("General", type="tab")

group_general.add("planning_approach", bool_t, 0, "Whether to use planning (True) or proactive approach (False) for trajectory generation", True)
group_general.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 1.8, 0)
group_general.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.085, 0)
group_general.add("angular_sim_granularity", double_t, 0, "The granularity with which to check for collisions for rotations in radians", 0.1, 0)
group_general.add("forward_point_distance", double_t, 0, "The distance from the center point of the robot to place a local goal. Try to keep it below 0.5 m for proactive approach", 0.85, 0.25, 2.0)
group_general.add("person_model_radius", double_t, 0, "The radius of the circular representation of person-obstacle used by the sparse environment model", 0.4, 0.0, 2.0)
group_general.add("publish_traj_pcl", bool_t, 0, "Whether to publish PCL with explored trajectories", True)
group_general.add("publish_cost_grid_pcl", bool_t, 0, "Whether to publish PCL with the potential field generated by the cost function", True)

# SFM group parameters
group_sfm = gen.add_group("SFM", type="tab")

group_sfm.add("fov", double_t, 0, "Field of view of the robot", 2.00, 0.0, +3.14)
group_sfm.add("max_speed", double_t, 0, "maximum speed", 1.50, 0.00, 2.50)
group_sfm.add("mass", double_t, 0, "Description", 14.5, 0.1, 250.0) # 20.0
group_sfm.add("maneuverability", double_t, 0, "Description", 0.0065, 0.002, 0.010)
group_sfm.add("internal_force_factor", double_t, 0, "How much robot tries to reach the goal position using shortest path to goal. For non-planning approach keep it at approx. 4.2", 4.2, 0.0, 50.0)
group_sfm.add("interaction_force_factor", double_t, 0, "How much robot tries to maintain safe distance from obstacles. For non-planning approach keep it at approx. 11.0", 50.0, 0.0, 300.0)
group_sfm.add("min_force", double_t, 0, "Minimum force - vectors shorter than that will be extended, which may prevent from being stuck.", 5.0, 0.0, 100.0)
group_sfm.add("max_force", double_t, 0, "Maximum force - vectors longer than that will be truncated", 300.0, 0.0, 1500.0)

soi_enum = gen.enum([ gen.const("elliptical",      	int_t, 0, "a.k.a. v2014"),
                       gen.const("repulsive_evasive",	int_t, 1, "a.k.a. v2011")],
                     "Static Object Interaction")
group_sfm.add("static_object_interaction_type", int_t, 0, "Description", 0, 0, 1, edit_method=soi_enum)

boxi_enum = gen.enum([ gen.const("box_other_objects",	int_t, 0, "Specify"),
                       gen.const("box_all_objects",	int_t, 1, "Specify"),
                       gen.const("circle",				int_t, 2, "Specify"),
                       gen.const("ellipse",				int_t, 3, "Specify"),
                       gen.const("none",				int_t, 4, "Specify")],
                     "Inflation Type")
group_sfm.add("inflation_type", int_t, 0, "Description", 3, 0, 4, edit_method=boxi_enum)

ofm_enum = gen.enum([ gen.const("go_towards_goal",	int_t, 0, "Specify"),
                      gen.const("rotate_left",		int_t, 1, "Specify")],
                     "Opposite Force Method")
group_sfm.add("oppsite_force_method", int_t, 0, "Description", 0, 0, 1, edit_method=ofm_enum)
group_sfm.add("disable_interaction_forces", bool_t, 0, "Description", False)

# Fuzzy Inference System group parameters
group_fis = gen.add_group("FIS", type="tab")

group_fis.add("force_factor", double_t, 0, "Factor to multiply resultant human action force with", 30.0, 0.0, 100.0)
group_fis.add("human_action_range", double_t, 0, "Distance at which any human action force fade completely", 8.0, 0.0, 10.0)

# Trajectory generation group parameters
group_traj = gen.add_group("Trajectory", type="tab")

group_traj.add("force_internal_amplifier_min", double_t, 0, "Description", 0.12, 0.0, 10.0)
group_traj.add("force_internal_amplifier_max", double_t, 0, "Bigger value may provide higher speeds and may help with stucks at cluttered areas", 2.12, 0.0, 10.0)
group_traj.add("force_internal_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 0.2, 0.0, 10.0)

group_traj.add("force_interaction_dynamic_amplifier_min", double_t, 0, "Description", 0.25, 0.0, 10.0)
group_traj.add("force_interaction_dynamic_amplifier_max", double_t, 0, "Description", 0.25, 0.0, 10.0)
group_traj.add("force_interaction_dynamic_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

group_traj.add("force_interaction_social_amplifier_min", double_t, 0, "Description", 0.0, 0.0, 10.0)
group_traj.add("force_interaction_social_amplifier_max", double_t, 0, "Description", 2.0, 0.0, 10.0)
group_traj.add("force_interaction_social_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 1.0, 0.0, 10.0)

group_traj.add("force_interaction_static_amplifier_min", double_t, 0, "Description", 0.025, 0.0, 10.0)
group_traj.add("force_interaction_static_amplifier_max", double_t, 0, "Description", 3.275, 0.0, 10.0)
group_traj.add("force_interaction_static_amplifier_granularity", double_t, 0, "Distance between values (within min and max) that should be selected for sampling", 0.65, 0.0, 10.0)

# Trajectory generation group parameters
group_cost = gen.add_group("Cost", type="tab")

group_cost.add("path_distance_scale", double_t, 0, "The weight for the path distance part of the cost function", 0.6, 0.0)
group_cost.add("goal_distance_scale", double_t, 0, "The weight for the goal distance part of the cost function", 0.8, 0.0)
group_cost.add("occdist_scale", double_t, 0, "The weight for the obstacle distance part of the cost function", 0.01, 0.0)
group_cost.add("ttc_scale", double_t, 0, "The weight for the time to collision cost function (scores whole trajectory instead of a single cell)", 3.0, 0.0)
group_cost.add("chc_scale", double_t, 0, "The weight for the cost function that penalizes robot heading changes", 1.0, 0.0)
group_cost.add("speedy_goal_scale", double_t, 0, "The weight for the cost function that penalizes high speeds near global goal", 12.0, 0.0)

group_cost.add("oscillation_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 0.05, 0.0)
group_cost.add("oscillation_reset_angle", double_t, 0, "The angle the robot must turn before oscillation flags are reset, in radians", 0.2, 0.0)

group_cost.add("scaling_speed", double_t, 0, "The absolute value of the velocity at which to start scaling the robot's footprint, in m/s", 0.25, 0.0)
group_cost.add("max_scaling_factor", double_t, 0, "The maximum factor to scale the robot's footprint by", 0.2, 0.0)

group_cost.add("ttc_rollout_time", double_t, 0, "The duration of maximum world state prediction to detect robot collision (further beyond `sim_time`)", 1.5, 0.0)
group_cost.add("ttc_collision_distance", double_t, 0, "The distance threshold for collision detection in TTC prediction", 0.05, 0.0)

group_cost.add("speedy_goal_distance", double_t, 0, "The distance threshold of penalization of high speeds near global goal", 0.85, 0.0)

# Diagnostics
group_diagnostics = gen.add_group("Diagnostics", type="tab")
group_diagnostics.add("log_trajectory_generation_samples", bool_t, 0, "Whether to print info on samples used for trajectory generation", False)
group_diagnostics.add("log_trajectory_generation_details", bool_t, 0, "Whether to print info on motion drivers (forces) of a specific trajectory", False)
group_diagnostics.add("log_trajectory_generation_fails", bool_t, 0, "Whether to print info on unsuccessful attempt to trajectory generation", False)
group_diagnostics.add("log_explored_trajectories", bool_t, 0, "Whether to print info on explored trajectories", False)
group_diagnostics.add("log_pts_of_explored_trajectories", bool_t, 0, "Whether to print info on points of explored trajectories", False)
group_diagnostics.add("log_trajectory_cost_details", bool_t, 0, "Whether to print info on cost of the best trajectory", False)

# Other
gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration.", False)

exit(gen.generate("hubero_local_planner", "hubero_local_planner", "HuberoPlanner"))
